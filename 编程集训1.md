哈希表学习：
    hash表的特性
        Hash 表是使用 O(1) 时间进行数据的插入删除和查找，但是 hash 表不保证表中数据的有序性，这样在 hash 表中查找最大数据或者最小数据的时间是 O(N) 。
    寻址和 hash 函数
        理想状态下 hash 足够大，每一数据保存在一个 hash 存储单元内，这样对于插入删除和查找某一个数据就可以直接得到。
        但是现实情况下 hash 表不可能无限大，而且理论上保存的数据的个数是没有限制的，这样保存的数据的数量就远远大于 hash 表的存储单元的数量。
        为了实现在 O(1) 内对数据进行插入删除和查找， 就必须将一个数据映射到 hash 表中的固定位置，这个映射函数就是 hash 函数。
        Hash 函数通过对数据进行计算得到一个在 hash 表中的位置地址。
        要选择较好的 hash 函数，以及 hash 表存储单元的数量，这样才能使保存在 hash 表中的数据均匀分布。
        由于存储的数据数量远远大于 hash 表存储单元的数量，所以再好的 hash 函数也可能使不同的数据得到相同的映射位置，这就造成了冲突。
    冲突解决
        分离链表
            解决这种冲突的第一种方法是借助链表来实现，就是将数据实际存放在与 hash 表存储单元相链接的链表中，而不是 hash 的存储单元中。
            例：https://images2018.cnblogs.com/blog/1251780/201803/1251780-20180317153146637-1947281827.png
            当产生冲突的时候，将两个数据都链接在同一 hash 存储单元保存的链表中。
            当一个存储单元保存的链表中有多个数据的时候，对于链表后面的数据的查找添加和删除就是不是严格意义上的 O(1) 了。
            一个好的 hash 函数可以使得这个链表很短。最坏情况下，当所有的数据都保存在一个 hash 单元指定的链表中的时候，那么这个 hash 就和链表一样了。
        开放地址
            使用开放地址方法解决冲突的时候，数据保存在 hash 表的存储单元中，但是当冲突发生的时候，要再次计算新的地址。
            常用的开放地址法是线性探查：当对一个数据进行插入删除或者查找的时候，通过 hash 函数计算其操作位置，若不符合要求，就检查下一个存储单元。
            除了线性探查外还有二次探查，再 hash 等等方法，都是当一次计算得到的位置不是要找到的数据的时候，怎样再次确定新的位置。
        完全哈希表
            采用分离链表的方式解决冲突的时候，当多个数据被映射到一个地址的时候，它们就形成了一个链表，要操作这其中的一个数据，
            那么就必须在这个链表中进行操作。
            如果 hash 函数选择的好的话，链表会很短，这样的操作近似 O(1)，它与链表的长度有关。
            基于此，对于数据的访问的最坏情况的访问也是 O(1) 的 hash 叫做完全 hash 表。
            这样的 hash 表是一个两级的 hash 表，第一级的 hash 与使用分离链表一样，但是 hash 存储单元中指向的不是一个链表，而是另一个 hash 表。
            例：https://images2018.cnblogs.com/blog/1251780/201803/1251780-20180317153147281-701319350.png
    常用算法
        直接定址法 ：地址集合和关键字集合大小相同
        数字分析法 ：根据需要hash的关键字的特点选择合适hash算法，尽量寻找每个关键字的不同点
        平方取中法：取关键字平方之后的中间极为作为哈希地址，一个数平方之后中间几位数字与数的每一位都相关，取得位数由表长决定。
            比如：表长为512,=2^9,可以取平方之后中间9位二进制数作为哈希地址。
        折叠法：关键字位数很多，而且关键字中每一位上的数字分布大致均匀的时候，可以采用折叠法得到哈希地址，除留取余法除P取余，可以选P为质数，
            或者不含有小于20的质因子的合数
        随机数法：通常关键字不等的时候采用此法构造哈希函数较恰当。

题目一 两数之和
    思路：
         先创建一个空字典，然后依次把target-nums[i]的值存入字典，存入一个就跟nums[i+1]去比较， 字典中的key为target-nums[i],value为i，
         也就是nums[i]在nums列表中的索引位置。当字典d中有nums[i+1]时，也就是target - nums[i] = nums[i+1]。
    代码：
        class Solution:
            def twoSum(self, nums, target):
                """
                :type nums: List[int]
                :type target: int
                :rtype: List[int]
                """
                length = len(nums)
                dic = {}

                for i in range(length):
                    a = target - nums[i]
                    if nums[i] in dic:
                        return dic[nums[i]], i
                    else:
                        dic[a] = i
    提交结果：
        ![](https://github.com/YoungKang1222/hello-world/blob/master/leetcode-1%20submission%20result.png)
         
